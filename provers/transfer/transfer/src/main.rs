// Copyright 2023 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use methods::{TRANSFER_ELF, TRANSFER_ID};

use risc0_zkvm::{serde::to_vec, Executor, ExecutorEnv, SegmentReceipt, SessionReceipt};

use clap::Parser;
use subxt::{
	config::WithExtrinsicParams,
	ext::{
		sp_core::{
			sr25519::{verify_batch, Pair as SubxtPair, Public, Signature},
			Pair as SubxtPairT,
		},
		sp_runtime::AccountId32,
	},
	tx::{BaseExtrinsicParams, PairSigner, PlainTip},
	OnlineClient, PolkadotConfig, SubstrateConfig,
};

// // Runtime types, etc
#[subxt::subxt(runtime_metadata_path = "./metadata.scale")]
pub mod substrate_node {}

use crate::substrate_node::runtime_types::{
	frame_system::AccountInfo, pallet_balances::AccountData,
};

type ApiType = OnlineClient<
	WithExtrinsicParams<SubstrateConfig, BaseExtrinsicParams<SubstrateConfig, PlainTip>>,
>;

async fn account_query(
	api: &ApiType,
	account: AccountId32,
) -> Result<Option<AccountInfo<u32, AccountData<u128>>>, subxt::Error> {
	let query = substrate_node::storage().system().account(&account);
	let query_result = api.storage().fetch(&query, None).await;
	query_result
}

#[derive(Parser, Debug)]
pub(crate) struct Arguments {
	#[clap(short, help = "Hex string of public key of receiver")]
	pub receiver: String,
	#[clap(short, help = "Transfer amount")]
	pub amount: u128,
	#[clap(
		long,
		help = "Signature string generated by sender with `subkey sign --hex  --message 68656c6c6f2c20776f726c64  --suri <sender's secret seed in HEX>`"
	)]
	pub sig: String,
	#[clap(short, help = "Hex of Secret Key of sender for signing")]
	pub sender_hex_seed: String,
}

#[tokio::main]
async fn main() {
	let args = Arguments::parse();

	let sender_pair =
		SubxtPair::from_seed(&array_bytes::hex2array_unchecked(&args.sender_hex_seed));
	let sender_public_key = sender_pair.public();
	let receiver_public_key = Public::from_raw(array_bytes::hex2array_unchecked(&args.receiver));
	let transfer_amount = args.amount;
	let message: [u8; 12] = array_bytes::hex2array_unchecked(&"68656c6c6f2c20776f726c64");

	let signature = Signature::from_raw(array_bytes::hex2array_unchecked(&args.sig));
	if !verify_batch(vec![&message], vec![&signature], vec![&sender_public_key.into()]) {
		panic!("Signature verification failed");
	}
	// Retrieve sender and recipient
	let api = OnlineClient::<PolkadotConfig>::new().await.unwrap();
	let sender_result = account_query(&api, sender_public_key.into());
	let receiver_result = account_query(&api, receiver_public_key.into());
	let sender = sender_result.await;
	let receiver = receiver_result.await;

	let sender_free_balance = sender.unwrap().unwrap().data.free;
	let receiver_free_balance = receiver.unwrap().unwrap().data.free;

	println!(
		"sender balance: {:?} recipient balance {:?}",
		sender_free_balance, receiver_free_balance
	);
	let receipt = transfer(sender_free_balance, receiver_free_balance, transfer_amount);

	// Verify receipt, panic if it's wrong
	receipt.verify(TRANSFER_ID).expect(
		"Code you have proven should successfully verify; did you specify the correct image ID?",
	);

	// TODO: Below needs update to use changes to receipts in 0.14.0
	let api = OnlineClient::<PolkadotConfig>::new().await.unwrap();
	let signer = PairSigner::new(sender_pair);

	println!("transfer id {:?}", TRANSFER_ID);

	// The segment receipts that SCALE can understand
	let substrate_session_receipt = receipt
		.segments
		.into_iter()
		.map(|SegmentReceipt { seal, index }| (seal, index))
		.collect();

	println!("Sending tx");
	api.tx()
		.sign_and_submit_then_watch_default(
			&substrate_node::tx().template_module().rollup_transfer(
				sender_public_key.into(),
				receiver_public_key.into(),
				substrate_session_receipt,
				receipt.journal,
			),
			&signer,
		)
		.await
		.unwrap()
		.wait_for_finalized()
		.await
		.unwrap();
	println!("Done");
}

// Compute the transfer inside the zkvm
fn transfer(sender: u128, recipient: u128, transfer_amount: u128) -> SessionReceipt {
	let env = ExecutorEnv::builder()
		// TODO: Figure out how to end u128s to guest here
		.add_input(&to_vec(&sender.to_be_bytes()).unwrap())
		.add_input(&to_vec(&recipient.to_be_bytes()).unwrap())
		.add_input(&to_vec(&transfer_amount.to_be_bytes()).unwrap())
		.build();

	// First, we make an executor, loading the 'multiply' ELF binary.
	let mut exec = Executor::from_elf(env, TRANSFER_ELF).unwrap();

	// Run the executor to produce a session.
	let session = exec.run().unwrap();

	// Prove the session to produce a receipt.
	let receipt = session.prove().unwrap();
	receipt
}
